---
title: "Representaci贸n digital de se帽ales anal贸gicas."
subtitle: "Electr贸nica II para Ing. Electr贸nica."
date: "24/11/2022"
author: "Fernando Alberto Miranda Bonomi"
format: revealjs
jupyter: python3
---

## Se帽ales anal贸gicas y digitales

Se帽al: variaci贸n de una magnitud f铆sica que se usa para transmitir informaci贸n. 

```{python}
#| label: fig1
#| fig-cap: "Ejemplo de se帽al $\\operatorname{sen}(2\\pi t)$"
import numpy as np
import matplotlib.pyplot as plt
formato_1 = {
    "font.size":20,
    "lines.linewidth":4,
    "lines.markersize":6/1.5*4,
    "figure.dpi":200,
    "figure.figsize":[10,6]}
def fig1():
    with plt.rc_context(formato_1):
        t = np.linspace(0,1,200)
        y = np.sin(2*np.pi*t)
        plt.figure(1)
        plt.plot(t,y)
        plt.xlim(0,1)
        plt.show()
fig1()
```

## Se帽al anal贸gica

Var铆a de forma cont铆nua. La informaci贸n es representada por su valor en forma directa.

```{python}
#| label: fig2
#| fig-cap: "Se帽al anal贸gica: nivel de agua en un dep贸sito."
def fig2():
    with plt.rc_context(formato_1):
        t = np.linspace(0,10,200)
        y = (1+0.2*t)*(t<5)+2.0*(t>=5)*(t<7)+(2-0.1*(t-7))*(t>=7)
        plt.figure(2)
        plt.plot(t,y)
        plt.xlim(0,10)
        plt.xlabel("t (minutos)")
        plt.draw()
fig2()
```

## Se帽al digital

Es una se帽al que toma valores discretos que representan s铆mbolos (n煤meros).

```{python}
#| label: fig3
#| fig-cap: "Se帽al digital: transmisi贸n serie 9600-8-n-1 del byte 0x5A"

def fig3():
    with plt.rc_context(formato_1):
        r = 9600
        ts = 1/r
        sps = 20
        t = 1000*np.linspace(-2*ts,10*ts,12*sps)
        y = np.repeat([1,1,0,0,1,0,1,1,0,1,0,1],sps)
        plt.figure(3)
        plt.plot(t,y)
        plt.xlim(np.min(t),np.max(t))
        plt.xlabel("t (ms)")
        plt.show()
fig3()
```

## Anal贸gico vs digital

:::: {.columns}

::: {.column width="49%"}

Se帽al Anal贸gica

- Toma valores de un conjunto cont铆nuo.
- Var铆a en forma cont铆nua con el tiempo.

:::

::: {.column width="2%"}

:::

::: {.column width="49%"}

Una se帽al digital

- Toma valores de un conjunto discreto.
- Var铆a de forma "discontinua" en el tiempo.

:::

::::

## Anal贸gico

- La descripci贸n exacta de una se帽al anal贸gica contiene infinita informaci贸n. 
  - Variaci贸n cont铆nua en el tiempo.
  - Variaci贸n cont铆nua en valor.
- No podemos aprovechar toda esa informaci贸n. 
  - Existe ruido e incertidumbre de medida.
  - El ancho de banda es limitado y por lo tanto tambi茅n tiene l铆mite la variaci贸n temporal.

## Representaci贸n digital

::: {.incremental}

- Las se帽ales digitales son equivalentes a n煤meros de precisi贸n finita.
- Todo lo que podemos medir lo podemos representar por n煤meros de precisi贸n finita (hay incertidumbre de medida).
- Por lo tanto *podemos representar la informaci贸n medible de una se帽al anal贸gica mediante una se帽al digital*.

:::

## Conversi贸n anal贸gica a digital.

- *Muestreo*: Medimos la se帽al anal贸gica peri贸dicamente para capturar la variaci贸n en el tiempo.
- *Cuantizaci贸n*: Describimos el resultado de cada medici贸n por un n煤mero de precisi贸n finita.
- *Codificaci贸n*: Representamos los n煤meros de alguna manera en el sistema digital.

----

### Muestreo

La frecuencia con que se toman muestras se denomina *frecuencia de muestreo*.

```{python}
#| label: fig4
# | fig-cap: Muestreo de una se帽al anal贸gica
def fig4():
    t = np.linspace(0,1,100)
    y = np.sin(2*np.pi*t)
    ts = np.linspace(0,1,6)
    ys = np.sin(2*np.pi*ts)
    with plt.rc_context(formato_1):
        plt.figure(4)
        plt.plot(t,y)
        plt.plot(ts,ys,'ro')
        plt.xlim(0,1)
        plt.show()
fig4()
```

----

### Cuantizaci贸n

```{python}
#| label: fig5
# | fig-cap: Cuantizaci贸n de muestras anal贸gicas.
qdivs = np.array([-1+k*2/16 for k in range(17)])
qcentros =(qdivs[1:]+qdivs[:-1])/2

def cuantiza(x):
    "x-> indices,cod,valores,lim_izq,lim_der"
    x=np.array(x)
    indices = np.zeros(x.shape,"i")
    cod = indices.copy()
    valores = np.zeros(x.shape,qcentros.dtype)
    lim_izq = np.zeros(x.shape,qdivs.dtype)
    lim_der = lim_izq.copy()
    for k in range(x.size):
        i=max(np.searchsorted(qdivs,x.item(k))-1,0)
        indices.itemset(k,i)
        cod.itemset(k,i-len(qcentros)//2)
        valores.itemset(k,qcentros[i])
        lim_izq.itemset(k,qdivs[i])
        lim_der.itemset(k,qdivs[i+1])
    return indices,cod,valores,lim_izq,lim_der

def fig5():
    ts = np.linspace(0,1,6)
    ys = np.sin(2*np.pi*ts)    
    _,_,yq,_,_ = cuantiza(ys)
    with plt.rc_context(formato_1):
        plt.figure(5)
        plt.plot(ts,ys,'o')
        plt.plot(ts,yq,'rx')
        plt.yticks(qdivs)
        plt.grid(axis='y',which='major')
        plt.xlim(0,1)
        plt.show()
# |-7|-6|-5|-4|-3|-2|-1| 0| 1| 2| 3| 4| 5| 6| 7|
fig5()
```

----

### Codificaci贸n

```{python}
#| label: fig6
# | fig-cap: Codificaci贸n
def nr_bin(x,nbits):
    def digitos(x,nbits):
        for k in range(nbits-1,-1,-1):
            if x&(1<<k):
                yield '1'
            else:
                yield '0'
    return ''.join(digitos(int(x),nbits))
def fig6():
    ts = np.linspace(0,1,6)
    ys = np.sin(2*np.pi*ts)
    ks,cs,_,_,_ = cuantiza(ys)
    text = [[k,f'{us:.4f}',uq,f'{n} -> "{nr_bin(n,4)}"'] for k,(us,uq,n) in enumerate(zip(ys,ks,cs))]
    with plt.rc_context(formato_1):
        plt.figure(6)
        a = plt.gca()
        a.axis("off")
        plt.table(
            cellText=text,
            colLabels=["Nro. muestra","Tensi贸n","Nr.Intervalo","Codigo"],
            bbox=[0,0,1,1],
            cellLoc="center")
        plt.show()
fig6()
```

## Conversi贸n digital a anal贸gica.

- Recorremos las muestras digitales seg煤n la *frecuencia de muestreo*.
- Modificamos una tensi贸n o corriente de salida para que tome valores proporcionales a cada muestra.
- Usamos un filtro para interpolar entre las muestras y obtener una variaci贸n suave.
    - Esto se llama *reconstrucci贸n*

----

```{python}
#| label: fig7
#| fig-cap: Conversi贸n D/A f=1 fs=5
import scipy.signal as signal
def fig7(f=1,seno=True,fs=5):
    tmin = -3
    tmax = 6
    Ns = (tmax-tmin)*fs+1
    ts = np.linspace(tmin,tmax,Ns)
    func = np.sin if seno else np.cos
    ys = func(2*np.pi*f*ts)
    _,_,yq,_,_ = cuantiza(ys)
    interp = 20
    paso = ts[1]-ts[0]
    textra = (paso*(interp-1)/interp)
    t = np.linspace(tmin,tmax+textra,Ns*interp)

    y = np.repeat(yq,20)
    sos = signal.butter(N=5,
                        Wn=fs/2*1.1,
                        btype='low',
                        analog=False,
                        output="sos",
                        fs=fs*interp)
    yf = signal.sosfiltfilt(sos,y)
    fmt = formato_1|{
          "lines.markeredgewidth":3,
          "figure.figsize":[12,6*12/10]}
    with plt.rc_context(fmt):
        plt.figure(7)
        plt.plot(t,func(2*np.pi*f*t),label="Original")
        plt.plot(ts,yq,'x',label="Muestras")
        plt.plot(t,y,label="Salida DAC")
        plt.plot(t,yf,'--',label="Filtrado")
        plt.xlim(0,3)
        plt.legend(ncol=4,loc="lower center",bbox_to_anchor=(0.5,1))
fig7()
```
----
```{python}
#| label: fig7_f2.5_sen
#| fig-cap: Conversi贸n D/A f=2.5 fs=5 (coseno)
fig7(2.5,seno=False)
```
----
```{python}
#| label: fig7_f2.5_cos
#| fig-cap: Conversi贸n D/A f=2.5 fs=5 (seno)
fig7(2.5)
```

----
```{python}
#| label: fig7_f3
#| fig-cap: Conversi贸n D/A f=3.5 fs=5
fig7(3.5)
```

----
```{python}
#| label: fig7_f4
#| fig-cap: Conversi贸n D/A f=4 fs=5
fig7(4)
```

----
```{python}
#| label: fig7_f5s
#| fig-cap: Conversi贸n D/A f=5 fs=5 (seno)
fig7(5)
```

----
```{python}
#| label: fig7_f5c
#| fig-cap: Conversi贸n D/A f=5 fs=5 (coseno)
fig7(5,False)
```

## Teorema de Nyquist-Shannon

Es posible reconstruir perfectamente una se帽al anal贸gica *limitada en ancho de banda* de ancho de banda $B$ a partir de muestras de la misma tomadas con frecuencia de muestreo $f_s$ **si y solo si**

$$ f_s > 2B $$

A la frecuencia l铆mite se la denomina frecuencia de Nyquist

$$f_n=\dfrac{f_s}{2}$$

## Rango din谩mico y error de cuantizaci贸n

El teorema de Nyquist-Shannon considera muestras tomadas con precisi贸n infinita. En la pr谩ctica es necesario cuantizar las muestras para poder representarlas de forma digital. En ese caso se introduce una distorsi贸n conocida como *ruido de cuantizaci贸n* que limita el *rango din谩mico* de la se帽al.

----

```{python}
#| label: fig8
#| fig-cap: Se帽al continua, se帽al cuantizada con 4 bits (16 intervalos) y ruido de cuantizaci贸n.

def fig8():
    t = np.linspace(0,1,200)
    y = np.sin(2*np.pi*t)
    _,_,yq,_,_ = cuantiza(y)
    
    with plt.rc_context(formato_1):
        plt.figure(8)
        plt.plot(t,y)
        plt.plot(t,yq)
        plt.plot(t,yq-y)
        plt.show()
fig8()
```


